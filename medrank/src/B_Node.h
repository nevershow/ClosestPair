
#ifndef __B_NODE_H
#define __B_NODE_H
#include <cstring>

class B_Tree;

struct pair {
	// key表示数据库中一个点投影在某位投票者（即line)上的长度
    double key;
    // 当Level = 0 value为ObjectID
    // 当Level > 0, value为指针（实际上是块的编号）
    unsigned short value;
    pair() {
        key = 0.0, value = 0;
    }
};

// -------------------------------------------------------------------
// B_Node类成员相关信息：1.存有内存中的一个块（页面）大小的数据；2.该页面的基本
// 信息（如页面长度，键值对数量，块编号等); 3.调度本块数据的成员函数
// -------------------------------------------------------------------
// 内存中的一个B_Node类型数据对应磁盘中一个文件里的一个块
// -------------------------------------------------------------------
class B_Node {
public:
    B_Node(int level_ = -1, B_Tree * b_tree_ = nullptr);

    ~B_Node();

	// -------------------------------------------------------------------
    // 给块中增加新的键值对
    // -------------------------------------------------------------------
    void add_new_child(double key, unsigned short value) {
        pairs[num_entries].key = key;
        pairs[num_entries].value = value;
        num_entries++;
    }

	// -------------------------------------------------------------------
    // 设置本块的左相邻块的编号
    // -------------------------------------------------------------------
    void set_left_sibling(int index) {
        left_sibling = index;
    }

	// -------------------------------------------------------------------
    // 设置本块的右相邻块的编号
    // -------------------------------------------------------------------
    void set_right_sibling(int index) {
        right_sibling = index;
    }

	// -------------------------------------------------------------------
    // 判断当前块存储的数据是否已满
    // -------------------------------------------------------------------
    bool isFull() {
        return num_entries >= capacity;
    }

	// -------------------------------------------------------------------
    // 返回块的编号
    // -------------------------------------------------------------------
    int get_block() {
        return block_index;
    }

	// -------------------------------------------------------------------
    // 返回本块在B+树中所属层级
    // -------------------------------------------------------------------
    int getLevel() {
        return level;
    }

	// -------------------------------------------------------------------
    // 返回右相邻块的编号
    // -------------------------------------------------------------------
    int getRightSibling() {
        return right_sibling;
    }

	// -------------------------------------------------------------------
    // 返回左相邻块的编号
    // -------------------------------------------------------------------
    int getLeftSibling() {
        return left_sibling;
    }

	// -------------------------------------------------------------------
    // 返回本块存储键值对的数量
    // -------------------------------------------------------------------
    int getEntriesNum() {
        return num_entries;
    }

	// -------------------------------------------------------------------
    // 返回本块第一个键值对的key
    // -------------------------------------------------------------------
    double get_key_of_node() {
        return pairs[0].key;
    }

	// -------------------------------------------------------------------
    // 通过index定位本块的某个键值对并返回该键值对
    // -------------------------------------------------------------------
    pair getPairByIndex(int index) {
        return pairs[index];
    }

    void new_block();
    void restore(B_Tree* b_tree, int block);
    void write_to_buffer(char *buffer);
    void read_from_buffer(char *buffer);

private:
    const int capacity = 100;        // 最多储存键值对的数量

    int block_index;
    bool dirty;

    int level;                       // 高度，叶子节点使用高度判断
    int num_entries;                 // 键值对的数量
    int left_sibling, right_sibling; // 左边相邻的页和右边相邻的页（使用块的编号代替指针），若没有设置为-1
    pair *pairs;                     // 键值对数组, 最多储存100个

    B_Tree *b_tree;
};

#endif
